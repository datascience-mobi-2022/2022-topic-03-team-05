---
title: "Probe_DataANalysis"
author: "MSalein"
date: "7 5 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## load the dataset

```{r}
FullData <- read.table("C:/Dokumente/Uni/FS 4/Data Analysis/RDeeP_HeLa_Interphase.csv", header = TRUE, row.names=1, sep = ";") 
##forward slash or double back slash because "\" is an escape character

head(rownames(FullData),12) 
head(colnames(FullData),12)

head(FullData)
anzahlcol = ncol(FullData)
dim(FullData)
```

There are different amounts of protein in each replicate. This is shown for the six replicates for the first protein in the data set.

```{r}

colRep1ctrl = seq(1, 150, 6) ##all columns with measurements from rep1 control sample 
colRep2ctrl = seq(2, 150, 6) ##all columns with measurements from rep2 control sample
colRep3ctrl = seq(3, 150, 6) ##all columns with measurements from rep3 control sample
colRep1rnase = seq(4, 150, 6) ##all columns with measurements from rep1 rnase sample
colRep2rnase = seq(5, 150, 6) ##all columns with measurements from rep2 rnase sample
colRep3rnase = seq(6, 150, 6) ##all columns with measurements from rep3 rnase sample

all_colrep = matrix(c(colRep1ctrl, colRep2ctrl, colRep3ctrl, colRep1rnase, colRep2rnase, colRep3rnase), byrow = TRUE, nrow = 6)

alls = vector()
for (i in 1:6){
  alls[i] = rowSums(FullData[1,all_colrep[i,]])
}
alls
```

```{r}
y = 1:25
meanRep1ctrl = sapply(FullData[,colRep1ctrl], mean) ##falsch!!! berechnet die mean von den Spalten und nicht für jedes Protein einzeln
meanRep2ctrl = sapply(FullData[,colRep2ctrl], mean) 
meanRep3ctrl = sapply(FullData[,colRep3ctrl], mean)

for (i in 1398:1399) {plot(y, FullData[i,colRep1ctrl], col = "black") ##plot des Rep1 ctrl sample für protein 1
points(y, FullData[i,colRep2ctrl], col = "black") ##plot des Rep2 ctrl sample für protein 1
points(y, FullData[i,colRep3ctrl], col = "black") ##plot des Rep3 ctrl sample für protein 1
##points(x, y) wenn man die in einem Koordinatensystem haben will


points(y, FullData[i,colRep1rnase], col = "magenta")
points(y, FullData[i,colRep2rnase], col = "magenta")
points(y, FullData[i,colRep3rnase], col = "magenta")

}

```

Protein 1 hat keinen Shift? (Data noch nicht normalisiert!)

##rumspielen Maxima

```{r}

## Maximum für jedes bzw. ersten vierzig Proteine für Rep1 des ctrl sample und in welcher Fraktion die Maxima liegen
maxRep1ctrl = apply(FullData[1:40,colRep1ctrl],1,max)
for(i in 1:40){
    for (j in 1:150){
        if(FullData[i,j]==maxRep1ctrl[i]){
           print(names(FullData)[j])
        }
    }
}


##Maximum der ersten Replicatreihe des Ctrl samples für das erste Protein
Rep1ctrl = FullData[1,colRep1ctrl] ## Werte für jede Fraktion des Rep1 beim ersten Protein
max(Rep1ctrl) ##Maximum davon (stimmt mit Angabe der Fraktion aus oben drüber liegendem Code überein :) )

##wie viele 0 gibt es in jeder Zeile?
rowSums(FullData==0)
x = which(rowSums(FullData==0)==150) ##welche Proteine haben nur 0 in der Zeile?
nozeros = which(rowSums(FullData==0)==0) ##welche proteine haben gar keine 0?

```

##normalization Formel Data normalization to be between 0 and 100: zi = (xi -- min(x)) / (max(x) -- min(x)) \* 100

```{r}

meanFrac1Repctrl = apply(FullData[,1:3],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 1

sdFrac1Repctrl = apply(FullData[,1:3],1,sd) ##sd for each protein in triplicates of ctrl sample in fraction 1

##Abweichungen vom mean für ctrl sample in fraction 1 für protein 1
n1_1 = FullData[1,1]-157910.133
n1_2 = FullData[1,2]-157910.133
n1_3 = FullData[1,3]-157910.133

##Z-Transformation, aber dann ist Integral 1 oder? Wie wäre es mit Integral = 100 (Paper Maiwen)
z1_1 = (FullData[1,1]-157910.133)/30636.8458
z1_2 = (FullData[1,2]-157910.133)/30636.8458
z1_3 = (FullData[1,3]-157910.133)/30636.8458


meanFrac2Repctrl = apply(FullData[,7:9],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 2
```

0 durch NA ersetzen in Kopie naData warum sind mean und sd gleich, egal ob man NA macht oder nicht? und egal, ob na.rm

```{r}
naData = data.frame(FullData)
naData[naData==0] = NA ## turn all 0 into NA

naData = naData[-2089,] ##deleting row containing all 0

nameanFrac1Repctrl = apply(naData[,1:3],1,mean, na.rm = TRUE)## mean und Co erst nach normalization auf 100!
nasdFrac1Repctrl = apply(naData[,1:3],1,sd, na.rm = TRUE)

```


```{##Abweichungen vom mean für ctrl sample in fraction 1 für protein 1}
n1_1 = naData[1,1]-157910.133
n1_2 = naData[1,2]-157910.133
n1_3 = naData[1,3]-157910.133

##Z-Transformation, aber dann ist Integral 1 oder? Wie wäre es mit Integral = 100 (Paper Maiwen)
z1_1 = (naData[1,1]-157910.133)/30636.8458
z1_2 = (naData[1,2]-157910.133)/30636.8458
z1_3 = (naData[1,3]-157910.133)/30636.8458


nameanFrac2Repctrl = apply(naData[,7:9],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 2

```

Versuch der Normalisierung auf 100, in welcher Einheit sind eigentlich unsere Daten???
Versuch des fittens einer Gaussian curve (sehr freihändig!)
```{r}
##normalize each replicate for each protein to an amount of 100
##example for rep1 ctrl sample

rep1ctrlnormData = t(apply(naData[, colRep1ctrl], 1, function(x) x/(sum(x, na.rm = TRUE)/100))) 

##mit FullData
repvgl = t(apply(FullData[, colRep1ctrl], 1, function(x) x/(sum(x)/100))) ##mit naData: was genau ist hier der Vorteil? und Unterschied (werte sehen soweit gleich aus, außer,dass bei oberem NA Werte auftreten, die in repvgl 0 sind)
rep2ctrlnormData = t(apply(FullData[, colRep2ctrl], 1, function(x) x/(sum(x)/100)))
rep3ctrlnormData = t(apply(FullData[, colRep3ctrl], 1, function(x) x/(sum(x)/100)))
rep1rnasenormData = t(apply(FullData[, colRep1rnase], 1, function(x) x/(sum(x)/100)))
rep2rnasenormData = t(apply(FullData[, colRep2rnase], 1, function(x) x/(sum(x)/100)))
rep3rnasenormData = t(apply(FullData[, colRep3rnase], 1, function(x) x/(sum(x)/100)))

mu = 4.7
sigma = 1.4
x = seq(1,25,0.1)
l = 91*dnorm(x,mean=mu,sd=sigma)
datprot1 = vector()
for (i in 1:25){
  datprot1[i] = (rep1ctrlnormData[1,i] + rep2ctrlnormData[1,i] + rep3ctrlnormData[1,i])/3
}
datprot1[is.na(datprot1)] = 0
plot(datprot1, main = "amount of 1433B_HUMAN in mean of control sample replicates", xlab = "fractions on sucrose gradient", ylab = "percentage of protein amount", col = "blue"); lines(datprot1, lwd=2, col = "blue"); lines(x, l, col = "magenta", lwd=2)
```

plot suchen und gefunden für mit shift
```{r}
for (i in 3927:3927) {
  plot(y, rep1ctrlnormData[i,], col = "black", type = "n", main = "amount of NOP9_HUMAN (all 6 replicates)", xlab = "fractions of sucrose gradient", ylab = "percentage of protein amount") ##plot aller samples für protein 900-930 normalisiert auf 100 (wenn es geklappt hat)
  lines(y,rep1ctrlnormData[i,], col = "black")
  lines(y, rep2ctrlnormData[i,], col = "black") ##plot des Rep2 ctrl sample für protein 1
  lines(y, rep3ctrlnormData[i,], col = "black") ##plot des Rep3 ctrl sample für protein 1
  lines(y, rep1rnasenormData[i,], col = "magenta")
  lines(y, rep2rnasenormData[i,], col = "magenta")
  lines(y, rep3rnasenormData[i,], col = "magenta")

}
##points(x, y) wenn man die in einem Koordinatensystem haben will

apply(rep1ctrlnormData[1:3,],1, function(x) plot(1:25, x)) ## plotten der ersten 30 auf 100 normalisierten Proteine vom rep1 ctrl

countnas = rowSums(is.na(rep1ctrlnormData)) ##wie viele NAs sind im ersten Rep ctrl von jedem Protein


## überprüfen der normalisierung mit rowSums(rep1ctrlnormData)
library(pheatmap)
pheatmap(repvgl[1:20,]) 

```
plot suchen und gefunden für ohne shift:
```{r}
for (i in 413:415) {
  plot(y, rep1ctrlnormData[i,], col = "black", type = "n", main = "amount of ARI1A_HUMAN (all 6 replicates)", xlab = "fractions of sucrose gradient", ylab = "percentage of protein amount") ##plot aller samples für protein 900-930 normalisiert auf 100 (wenn es geklappt hat)
  lines(y,rep1ctrlnormData[i,], col = "black")
  lines(y, rep2ctrlnormData[i,], col = "black") ##plot des Rep2 ctrl sample für protein 1
  lines(y, rep3ctrlnormData[i,], col = "black") ##plot des Rep3 ctrl sample für protein 1
  lines(y, rep1rnasenormData[i,], col = "magenta")
  lines(y, rep2rnasenormData[i,], col = "magenta")
  lines(y, rep3rnasenormData[i,], col = "magenta")

}
```


```{r}
dat = data.frame(c(30, 70, 80, 0), c(0, 0, 50, 50), c(100, 270, 30, 90))
rowsu = rowSums(dat)
dat1 = t(apply(dat, 1, function(x)x/(sum(x)/10)))
dat1
heatmap(dat1)

```

eigenen data frame für jedes Replikat von allen Proteinen

```{r}
rep1ctrldat = FullData[,colRep1ctrl] 
rep2ctrldat = FullData[,colRep2ctrl]
```

Are all numbers stored as numeric?
```{r}
sum(sapply(FullData, is.numeric))




```
Protein 1 
```{r}
mittel = vector()
for (i in 1:25){
  mittel[i] = mean(t(naData[1,(i:i+2)]))
}
```

```{r}

```

