---
title: "Probe_DataANalysis"
author: "MSalein"
date: "7 5 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:



## load the dataset
```{r}
FullData <- read.table("C:/Dokumente/Uni/FS 4/Data Analysis/RDeeP_HeLa_Interphase.csv", header = TRUE, row.names=1, sep = ";") 
##forward slash or double back slash because "\" is an escape character

head(rownames(FullData),12) 
head(colnames(FullData),12)

head(FullData)
```

##rumspielen plotten
```{r}
echo =TRUE##??

anzahlcol = ncol(FullData)
colRep1ctrl = seq(1, 150, 6) ##alle Columns die rep1 ctrl enthalten
colRep2ctrl = seq(2, 150, 6) ##alle Columns die rep2 ctrl enthalten
colRep3ctrl = seq(3, 150, 6) ##alle Columns die rep3 ctrl enthalten
colRep1rnase = seq(4, 150, 6) ##alle columns die rep1 rnase enthalten
colRep2rnase = seq(5, 150, 6) ##alle columns die rep2 rnase enthalten
colRep3rnase = seq(6, 150, 6) ##alle columns die rep3 rnase enthalten

y = 1:25
meanRep1ctrl = sapply(FullData[,colRep1ctrl], mean) ##falsch!!! berechnet die mean von den Spalten und nicht für jedes Protein einzeln
meanRep2ctrl = sapply(FullData[,colRep2ctrl], mean) 
meanRep3ctrl = sapply(FullData[,colRep3ctrl], mean)

for (i in 1398:1427) {plot(y, FullData[i,colRep1ctrl], col = "black") ##plot des Rep1 ctrl sample für protein 1
points(y, FullData[i,colRep2ctrl], col = "black") ##plot des Rep2 ctrl sample für protein 1
points(y, FullData[i,colRep3ctrl], col = "black") ##plot des Rep3 ctrl sample für protein 1
##points(x, y) wenn man die in einem Koordinatensystem haben will


points(y, FullData[i,colRep1rnase], col = "magenta")
points(y, FullData[i,colRep2rnase], col = "magenta")
points(y, FullData[i,colRep3rnase], col = "magenta")
}
```
Protein 1 hat keinen Shift? (Data noch nicht normalisiert!)

##rumspielen Maxima
``` {r}

## Maximum für jedes bzw. ersten vierzig Proteine für Rep1 des ctrl sample und in welcher Fraktion die Maxima liegen
maxRep1ctrl = apply(FullData[1:40,colRep1ctrl],1,max)
for(i in 1:40){
    for (j in 1:150){
        if(FullData[i,j]==maxRep1ctrl[i]){
           print(names(FullData)[j])
        }
    }
}


##Maximum der ersten Replicatreihe des Ctrl samples für das erste Protein
Rep1ctrl = FullData[1,colRep1ctrl] ## Werte für jede Fraktion des Rep1 beim ersten Protein
max(Rep1ctrl) ##Maximum davon (stimmt mit Angabe der Fraktion aus oben drüber liegendem Code überein :) )

##wie viele 0 gibt es in jeder Zeile?
rowSums(FullData==0)
x = which(rowSums(FullData==0)==150) ##welche Proteine haben nur 0 in der Zeile?
which(rowSums(FullData==0)==0) ##welche proteine haben gar keine 0?

```

##normalization
Formel Data normalization to be between 0 and 100:
zi = (xi – min(x)) / (max(x) – min(x)) * 100


```{r}

meanFrac1Repctrl = apply(FullData[,1:3],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 1

sdFrac1Repctrl = apply(FullData[,1:3],1,sd) ##sd for each protein in triplicates of ctrl sample in fraction 1

##Abweichungen vom mean für ctrl sample in fraction 1 für protein 1
n1_1 = FullData[1,1]-157910.133
n1_2 = FullData[1,2]-157910.133
n1_3 = FullData[1,3]-157910.133

##Z-Transformation, aber dann ist Integral 1 oder? Wie wäre es mit Integral = 100 (Paper Maiwen)
z1_1 = (FullData[1,1]-157910.133)/30636.8458
z1_2 = (FullData[1,2]-157910.133)/30636.8458
z1_3 = (FullData[1,3]-157910.133)/30636.8458


meanFrac2Repctrl = apply(FullData[,7:9],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 2
```

0 durch NA ersetzen in Kopie naData
warum sind mean und sd gleich, egal ob man NA macht oder nicht? und egal, ob na.rm
```{r}
naData = data.frame(FullData)
naData[naData==0] = NA

naData = naData[-2089,] ##löschen der Zeile, die nur 0 ausweist

nameanFrac1Repctrl = apply(naData[,1:3],1,mean, na.rm = TRUE)
nasdFrac1Repctrl = apply(naData[,1:3],1,sd, na.rm = TRUE)

##Abweichungen vom mean für ctrl sample in fraction 1 für protein 1
n1_1 = naData[1,1]-157910.133
n1_2 = naData[1,2]-157910.133
n1_3 = naData[1,3]-157910.133

##Z-Transformation, aber dann ist Integral 1 oder? Wie wäre es mit Integral = 100 (Paper Maiwen)
z1_1 = (naData[1,1]-157910.133)/30636.8458
z1_2 = (naData[1,2]-157910.133)/30636.8458
z1_3 = (naData[1,3]-157910.133)/30636.8458


nameanFrac2Repctrl = apply(naData[,7:9],1,mean) ##mean for each protein in triplicates of ctrl sample in fraction 2

```

Versuch der Normalisierung auf 100, in welcher Einheit sind eigentlich unsere Daten???
```{r}

##eigenen Data frame für jedes Replikat (also 6 data frames), jeweils für alle Proteine und auf 100 normalisiert

rep1ctrlnormData = t(apply(naData[, colRep1ctrl], 1, function(x) x/(sum(x, na.rm = TRUE)/100))) ##mit FullData
repvgl = t(apply(FullData[, colRep1ctrl], 1, function(x) x/(sum(x)/100))) ##mit naData: was genau ist hier der Vorteil? und Unterschied (werte sehen soweit gleich aus, außer,dass bei oberem NA Werte auftreten, die in repvgl 0 sind)
rep2ctrlnormData = t(apply(FullData[, colRep2ctrl], 1, function(x) x/(sum(x)/100)))
rep3ctrlnormData = t(apply(FullData[, colRep3ctrl], 1, function(x) x/(sum(x)/100)))
rep1rnasenormData = t(apply(FullData[, colRep1rnase], 1, function(x) x/(sum(x)/100)))
rep2rnasenormData = t(apply(FullData[, colRep2rnase], 1, function(x) x/(sum(x)/100)))
rep3rnasenormData = t(apply(FullData[, colRep3rnase], 1, function(x) x/(sum(x)/100)))

for (i in 3927:3929) {plot(y, rep1ctrlnormData[i,], col = "black") ##plot aller samples für protein 900-930 normalisiert auf 100 (wenn es geklappt hat)
lines(y, rep2ctrlnormData[i,], col = "black") ##plot des Rep2 ctrl sample für protein 1
lines(y, rep3ctrlnormData[i,], col = "black") ##plot des Rep3 ctrl sample für protein 1
##points(x, y) wenn man die in einem Koordinatensystem haben will


lines(y, rep1rnasenormData[i,], col = "magenta")
lines(y, rep2rnasenormData[i,], col = "magenta")
lines(y, rep3rnasenormData[i,], col = "magenta")

lines
}


apply(rep1ctrlnormData[1:30,],1, function(x) plot(1:25, x)) ## plotten der ersten 30 auf 100 normalisierten Proteine vom rep1 ctrl

rowSums(is.na(rep1ctrlnormData)) ##wie viele NAs sind im ersten Rep ctrl von jedem Protein

## überprüfen der normalisierung mit rowSums(rep1ctrlnormData)
library(pheatmap)
pheatmap(repvgl[1:20,]) 



```
```{r}
dat = data.frame(c(30, 70, 80, 0), c(0, 0, 50, 50), c(100, 270, 30, 90))
rowsu = rowSums(dat)
dat1 = t(apply(dat, 1, function(x)x/(sum(x)/10)))
dat1
heatmap(dat1)

```
eigenen data frame für jedes Replikat von allen Proteinen
```{r}
rep1ctrldat = FullData[,colRep1ctrl] 
rep2ctrldat = FullData[,colRep2ctrl]
```

